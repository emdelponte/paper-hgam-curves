library(readr)
library(dplyr)
library(tidyr)
library(tibble)
library(purrr)
library(ggplot2)
library(mgcv)
library(pracma)
library(pheatmap)
library(lme4)
library(lmerTest)
library(emmeans)
library(multcompView)
library(cowplot)
library(ggrepel)
library(ggdendro)
library(patchwork)
library(DHARMa)
library(stringr)
library(glue)
theme_set(theme_classic(base_size = 14))
# Chunk 2: setup-settings
#| label: setup-settings
file_path  <- "maize_bipolaris.csv"
# Data window (as in your script)
dae_min <- 20
dae_max <- 116
# Minimum number of assessments per curve_id to retain
min_assess <- 5
# Beta boundary adjustment
eps <- 1e-4
# Functional clustering
k_clusters <- 4
# Time grid for functional distances / plots
grid_n <- 140
# Reference environment used for "environment-adjusted" mean curves
# Chunk 3: data-read
#| label: data-read
dat0 <- read_csv(file_path, show_col_types = FALSE)
dat0 <- dat0 |>
filter(DAE < dae_max, DAE > dae_min)
# Expected columns: Ambiente, Hibrido, Parcela, DAE, Bipolaris
dat <- dat0 %>%
transmute(
Ambiente  = factor(Ambiente),
Hibrido   = factor(Hibrido),
DAE       = as.numeric(DAE),
bipolaris = as.numeric(Bipolaris) / 100  # % -> proportion
) %>%
filter(!is.na(Ambiente), !is.na(Hibrido),
!is.na(DAE), !is.na(bipolaris)) %>%
mutate(
curve_id = interaction(Ambiente, Hibrido), drop = TRUE, sep = "|") %>%
arrange(curve_id, DAE)
# Retain curves with at least min_assess time points
curve_n <- dat %>% count(curve_id, name = "n_assess")
dat <- dat %>%
left_join(curve_n, by = "curve_id") %>%
filter(n_assess >= min_assess) %>%
select(-n_assess)
# Beta regression requires 0 < y < 1
dat <- dat %>%
mutate(y = pmin(pmax(bipolaris, eps), 1 - eps))
message("Rows: ", nrow(dat),
" | curves: ", n_distinct(dat$curve_id),
" | hybrids: ", n_distinct(dat$Hibrido),
" | envs: ", n_distinct(dat$Ambiente))
# Chunk 4: data-resistance
#| label: data-resistance
bipolaris_df <- data.frame(
Hibrido = c(
"AG 8701 PRO4","AG 8707 PRO4","AG 9021 PRO3","AS 1757 PRO4","AS 1868 PRO4",
"AS 1955 PRO4","B 2801 PWU","CRWX03","DKB 230 PRO3","DKB 242 PRO4",
"MG 616 PWU","P 3016 VYHR","T 1503 PWU"
),
resistance = c("MR","MR","MR","MR","R","MR","MR","R","MR","MR","MR","R","MR"),
stringsAsFactors = FALSE
)
dat <- dat %>%
left_join(bipolaris_df, by = "Hibrido") %>%
transmute(
y          = as.numeric(y),
DAE        = as.numeric(DAE),
Ambiente   = factor(Ambiente),
Hibrido    = factor(Hibrido),
curve_id   = factor(curve_id),
resistance = factor(resistance)
) %>%
as.data.frame()
str(dat)
dat |>
group_by(Ambiente) |>
count(DAE)
# Chunk 5: helpers-scalars
#| label: helpers-scalars
# T50: time when y reaches 0.5*ymax (linear interpolation)
t50_interp <- function(time, y){
o <- order(time)
time <- time[o]; y <- y[o]
ymax <- max(y, na.rm = TRUE)
thr  <- 0.5 * ymax
if(all(y < thr, na.rm = TRUE)) return(NA_real_)
k <- which(y >= thr)[1]
if(k == 1) return(time[1])
t1 <- time[k-1]; t2 <- time[k]
y1 <- y[k-1];    y2 <- y[k]
if(isTRUE(all.equal(y2, y1))) return(t2)
t1 + (thr - y1) * (t2 - t1) / (y2 - y1)
}
# Logistic fit: y(t)=K/(1+exp(-r(t-t0))) and r_norm = r*(tmax-tmin)
logistic_fit_rate <- function(time, y){
o <- order(time)
time <- time[o]; y <- y[o]
y <- pmin(pmax(y, 1e-4), 1 - 1e-4)
K0  <- max(y)
d   <- diff(y)
t00 <- if(length(d) > 0 && any(is.finite(d))) time[which.max(d) + 1] else median(time)
if(is.na(t00)) t00 <- median(time)
r0  <- 0.1
f <- tryCatch(
nls(
y ~ K / (1 + exp(-r * (time - t0))),
start = list(K = K0, r = r0, t0 = t00),
control = nls.control(maxiter = 200, warnOnly = TRUE)
),
error = function(e) NULL
)
if(is.null(f)) return(tibble(r = NA_real_, K = NA_real_, t0 = NA_real_, r_norm = NA_real_))
co  <- coef(f)
r   <- unname(co["r"])
K   <- unname(co["K"])
t0  <- unname(co["t0"])
dur <- max(time) - min(time)
tibble(r = r, K = K, t0 = t0, r_norm = r * dur)
}
# Chunk 6: scalars-per-curve
#| label: scalars-per-curve
curve_stats <- dat %>%
group_by(curve_id, Ambiente, Hibrido) %>%
summarise(
AUDPC     = pracma::trapz(DAE, y),
final_sev = y[which.max(DAE)],
T50       = t50_interp(DAE, y),
.groups   = "drop"
)
rate_df <- map_dfr(unique(curve_stats$curve_id), function(cid){
df <- dat %>% filter(curve_id == cid)
logistic_fit_rate(df$DAE, df$y) %>% mutate(curve_id = as.character(cid))
})
curve_stats <- curve_stats %>%
mutate(curve_id = as.character(curve_id)) %>%
left_join(rate_df, by = "curve_id") %>%
filter(is.finite(T50), is.finite(r_norm))
message("Curves with all scalar metrics: ", nrow(curve_stats))
#| label: gam-fit
set.seed(1)
m_gam <- mgcv::bam(
y ~ s(DAE, k = 10) +
s(DAE, Ambiente, bs = "fs", k = 4, m = 1) +
s(DAE, Hibrido,  bs = "fs", k = 4, m = 1) +
s(curve_id, bs = "re"),
family   = mgcv::betar(link = "logit"),
data     = dat,
method   = "fREML",
discrete = TRUE,
gamma    = 1.4,
select   = TRUE
)
mgcv::gam.check(m_gam)
AIC(m_gam)
summary(m_gam)
m_gam2 <- mgcv::bam(
y ~ s(DAE, k = 10) +
s(DAE, Ambiente, bs = "fs", k = 6, m = 2) +  # k↑, m=2
s(DAE, Hibrido,  bs = "fs", k = 6, m = 2) +
s(curve_id, bs = "re"),
family   = mgcv::betar(link = "logit"),
data     = dat,
method   = "fREML",
discrete = TRUE,
gamma    = 1.4,
select   = TRUE
)
mgcv::gam.check(m_gam2)
mgcv::gam.check(m_gam)
AIC(m_gam2)
AIC(m_gam)
summary(m_gam2)
m
summary(m_gam)
mgcv::gam.check(m_gam)
mgcv::gam.check(m_gam2)
AIC(m_gam, m_gam2)
BIC(m_gam, m_gam2)
pred_original <- predict(m_gam, type = "response")
pred_sugerido <- predict(m_gam2, type = "response")
cor(pred_original, pred_sugerido)  # Deve ser ~0.99+
dat$res_original <- residuals(m_gam, type = "pearson")
dat$res_sugerido <- residuals(m_gam2, type = "pearson")
library(ggplot2)
ggplot(dat, aes(DAE, res_original, color = Ambiente)) +
geom_point(alpha = 0.3) +
geom_smooth(se = FALSE) +
facet_wrap(~Ambiente) +
labs(title = "Modelo Original (k=4)")
tibble(
Modelo = c("k=4, m=1", "k=6, m=2"),
AIC = c(-4425.6, -4469.4),
BIC = c(-3886.9, -3892.1),
edf_total = c(112.6, 120.6),
edf_ambiente = c(17.5, 24.0),
k_index_min = c(1.08, 1.11)
)
# Desvio padrão dos resíduos por ambiente
dat %>%
group_by(Ambiente) %>%
summarise(
SD_k4 = sd(res_k4),
SD_k6 = sd(res_k6),
Melhoria = (SD_k4 - SD_k6) / SD_k4 * 100
) %>%
arrange(desc(Melhoria))
dat <- dat %>%
mutate(
res_k4 = residuals(m_gam, type = "pearson"),
res_k6 = residuals(m_gam2, type = "pearson")
)
# Desvio padrão dos resíduos por ambiente
dat %>%
group_by(Ambiente) %>%
summarise(
SD_k4 = sd(res_k4),
SD_k6 = sd(res_k6),
Melhoria = (SD_k4 - SD_k6) / SD_k4 * 100
) %>%
arrange(desc(Melhoria))
dat %>%
group_by(Ambiente) %>%
summarise(
n_curves = n_distinct(curve_id),
n_obs = n(),
SD_k4 = first(SD_k4),
SD_k6 = first(SD_k6),
Melhoria = first(Melhoria)
) %>%
arrange(desc(Melhoria))
dat
dat %>%
group_by(Ambiente) %>%
summarise(
n_curves = n_distinct(curve_id),
n_obs = n(),
SD_k4 = first(SD_k4),
SD_k6 = first(SD_k6),
Melhoria = first(Melhoria)
) %>%
arrange(desc(Melhoria))
summary(m_gam2)
dat <- dat %>%
mutate(
res_k4 = residuals(m_gam, type = "pearson"),
res_k6 = residuals(m_gam2, type = "pearson")
)
# Desvio padrão dos resíduos por ambiente
dat %>%
group_by(Ambiente) %>%
summarise(
SD_k4 = sd(res_k4),
SD_k6 = sd(res_k6),
Melhoria = (SD_k4 - SD_k6) / SD_k4 * 100
) %>%
arrange(desc(Melhoria))
dat %>%
group_by(Ambiente) %>%
summarise(
n_curves = n_distinct(curve_id),
n_obs = n(),
SD_k4 = first(SD_k4),
SD_k6 = first(SD_k6),
Melhoria = first(Melhoria)
) %>%
arrange(desc(Melhoria))
ggplot(dat, aes(DAE, res_original, color = Ambiente)) +
geom_point(alpha = 0.3) +
geom_smooth(se = FALSE) +
facet_wrap(~Ambiente) +
labs(title = "Modelo Original (k=4)")
AIC(m_gam, m_gam2)
BIC(m_gam, m_gam2)
#| label: gam-diagnostics
dat$mu_hat <- predict(m_gam, type = "response")
ggplot(dat, aes(mu_hat, y)) +
geom_point(alpha = 0.3) +
geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
labs(x = "Fitted", y = "Observed")
res <- residuals(m_gam, type = "pearson")
plot(dat$DAE, res)
abline(h = 0, lty = 2)
#| label: gam-diagnostics
dat$mu_hat <- predict(m_gam2, type = "response")
ggplot(dat, aes(mu_hat, y)) +
geom_point(alpha = 0.3) +
geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
labs(x = "Fitted", y = "Observed")
res <- residuals(m_gam2, type = "pearson")
plot(dat$DAE, res)
abline(h = 0, lty = 2)
#| label: pred-hybrid-curves
t_grid <- seq(min(dat$DAE), max(dat$DAE), length.out = grid_n)
env_ref <- levels(dat$Ambiente)[1]
cultivars <- levels(dat$Hibrido)
pred_cult <- map_dfr(cultivars, function(cv){
newd <- tibble(
DAE      = t_grid,
Ambiente = factor(env_ref, levels = levels(dat$Ambiente)),
Hibrido  = factor(cv, levels = levels(dat$Hibrido)),
curve_id = dat$curve_id[1]  # dummy; excluded below
)
mu <- predict(
m_gam2, newdata = newd, type = "response",
exclude = c("s(DAE,Ambiente)", "s(curve_id)")
)
tibble(Hibrido = cv, DAE = t_grid, mu = as.numeric(mu))
})
cult_score <- pred_cult %>%
group_by(Hibrido) %>%
summarise(mean_mu = mean(mu), .groups = "drop") %>%
arrange(mean_mu)
cult_score
#| label: utils-short-label
shorten_hybrid <- function(x) {
x <- gsub(" PRO[0-9]+| PWU| VYHR", "", x)
x <- gsub(" ", "", x)
x
}
#| label: functional-distance
# Wide matrix: rows = time, cols = hybrid
mat <- pred_cult %>%
select(DAE, Hibrido, mu) %>%
pivot_wider(names_from = Hibrido, values_from = mu) %>%
arrange(DAE)
pred_cult
#| label: functional-distance
# Wide matrix: rows = time, cols = hybrid
mat <- pred_cult %>%
select(DAE, Hibrido, mu) %>%
pivot_wider(names_from = Hibrido, values_from = mu) %>%
arrange(DAE)
dt_grid <- mean(diff(mat$DAE))
matX <- mat %>%
select(-DAE) %>%
as.matrix()
# Functional L2 distance (grid approximation)
D_cult <- as.matrix(dist(t(matX), method = "euclidean")) * sqrt(dt_grid)
hc <- hclust(as.dist(D_cult), method = "ward.D2")
cl_raw <- cutree(hc, k = k_clusters)
# Order clusters by mean severity (from cult_score)
cluster_rank_map <- tibble(Hibrido = names(cl_raw),
cluster_raw = as.integer(cl_raw)) %>%
left_join(cult_score %>% select(Hibrido, mean_mu), by = "Hibrido") %>%
group_by(cluster_raw) %>%
summarise(cluster_mean = mean(mean_mu, na.rm = TRUE), .groups = "drop") %>%
arrange(cluster_mean) %>%
mutate(cluster = row_number()) %>%
select(cluster_raw, cluster)
cluster_table2 <- tibble(Hibrido = names(cl_raw),
cluster_raw = as.integer(cl_raw)) %>%
left_join(cluster_rank_map, by = "cluster_raw") %>%
left_join(cult_score %>% select(Hibrido, mean_mu), by = "Hibrido") %>%
mutate(
phenotype = factor(cluster,
levels = 1:k_clusters,
labels = paste0("P", 1:k_clusters))
)
cluster_table2
#| label: figure-functional-panels
cols <- c("#D55E00", "#0072B2", "#009E73", "#CC79A7")[1:k_clusters]
phen_cols <- setNames(cols, levels(cluster_table2$phenotype))
pred_cult2 <- pred_cult %>%
left_join(cluster_table2 %>% select(Hibrido, phenotype), by = "Hibrido") %>%
mutate(hybrid_short = shorten_hybrid(Hibrido))
pred_cult2 <- left_join(pred_cult2, bipolaris_df)
label_df <- pred_cult2 %>%
group_by(Hibrido) %>%
filter(DAE == max(DAE, na.rm = TRUE)) %>%
ungroup()
p_hibridos <- ggplot(pred_cult2,
aes(x = DAE, y = mu, group = Hibrido, linetype  = resistance, color = phenotype)) +
geom_line(linewidth = 1.1, alpha = 0.95) +
ggrepel::geom_text_repel(
data = label_df,
aes(label = hybrid_short),
hjust = 0, direction = "y",
nudge_x = 2,
size = 2.8,
show.legend = FALSE,
segment.size = 0.2,
segment.alpha = 0.6
) +
expand_limits(x = max(pred_cult2$DAE, na.rm = TRUE) + 8) +
scale_color_manual(values = phen_cols, drop = FALSE) +
labs(x = "Days after emergence (DAE)",
y = "Environment-adjusted mean severity",
color = "Phenotype", linetype = "Resistance") +
theme(legend.position = "bottom")
ddata <- ggdendro::dendro_data(as.dendrogram(hc), type = "rectangle")
lab_map <- cluster_table2 %>%
mutate(label = Hibrido,
label_short = shorten_hybrid(Hibrido),
lab_col = phen_cols[as.character(phenotype)]) %>%
select(label, label_short, lab_col)
lab_df <- ddata$labels %>%
left_join(lab_map, by = c("label" = "label")) %>%
mutate(label_short = ifelse(is.na(label_short), shorten_hybrid(label), label_short))
p_dend <- ggplot() +
geom_segment(data = ddata$segments,
aes(x = x, y = y, xend = xend, yend = yend),
linewidth = 0.45) +
geom_text(data = lab_df,
aes(x = x, y = y - 0.02 * max(ddata$segments$y),
label = label_short, color = I(lab_col)),
angle = 90, hjust = 1, size = 3) +
labs(x = NULL, y = "Functional distance") +
theme_classic(base_size = 14) +
theme(axis.line.x = element_blank(),
axis.ticks.x = element_blank(),
axis.text.x  = element_blank()) +
coord_cartesian(clip = "off") +
theme(plot.margin = margin(t = 5.5, r = 5.5, b = 18, l = 5.5))
h_cut <- hc$height[length(hc$height) - (k_clusters - 1)]
p_dend <- p_dend +
geom_hline(yintercept = h_cut, linetype = "dashed",
linewidth = 0.5, color = "grey30")
fig_final <- (p_hibridos | p_dend) + plot_annotation(tag_levels = "A")
fig_final
# ggsave("Figure2_functional_phenotypes.png", fig_final, width = 12, height = 5.5, dpi = 300)
#| label: killer-select-pair
dfS <- curve_stats %>%
transmute(
curve_id  = as.character(curve_id),
AUDPC     = as.numeric(AUDPC),
final_sev = as.numeric(final_sev)
) %>%
filter(is.finite(AUDPC), is.finite(final_sev)) %>%
distinct(curve_id, .keep_all = TRUE) %>%
mutate(
AUDPC_z = as.numeric(scale(AUDPC)),
final_z = as.numeric(scale(final_sev))
)
pairs_scalar <- crossing(
dfS %>% rename_with(~ paste0(.x, ".x"), -curve_id) %>% rename(curve_id.x = curve_id),
dfS %>% rename_with(~ paste0(.x, ".y"), -curve_id) %>% rename(curve_id.y = curve_id)
) %>%
filter(curve_id.x < curve_id.y) %>%
mutate(
scalar_dist = sqrt((AUDPC_z.x - AUDPC_z.y)^2 +
(final_z.x - final_z.y)^2)
) %>%
arrange(scalar_dist)
thr  <- quantile(pairs_scalar$scalar_dist, 0.03, na.rm = TRUE)
cand <- pairs_scalar %>% filter(scalar_dist <= thr)
interp_curve <- function(id){
df <- dat %>% filter(as.character(curve_id) == id) %>% arrange(DAE)
approx(df$DAE, df$y, xout = t_grid, rule = 2)$y
}
dt <- mean(diff(t_grid))
cand2 <- cand %>%
rowwise() %>%
mutate(
func_dist = {
y1 <- interp_curve(curve_id.x)
y2 <- interp_curve(curve_id.y)
sqrt(sum((y1 - y2)^2) * dt)
}
) %>%
ungroup()
best <- cand2 %>%
arrange(desc(func_dist), scalar_dist) %>%
slice(1)
id1 <- best$curve_id.x
id2 <- best$curve_id.y
best
#| label: killer-plot-raw
plot_pair <- dat %>%
filter(as.character(curve_id) %in% c(id1, id2)) %>%
mutate(curve = if_else(as.character(curve_id) == id1, "A", "B"))
s1 <- dfS %>% filter(curve_id == id1)
s2 <- dfS %>% filter(curve_id == id2)
ann <- glue(
"AUDPC  A={round(s1$AUDPC,2)}  B={round(s2$AUDPC,2)}\n",
"Final   A={round(s1$final_sev,2)}  B={round(s2$final_sev,2)}\n",
"d_S={signif(best$scalar_dist,3)}   d_F={signif(best$func_dist,3)}"
)
y_top <- max(plot_pair$y, na.rm = TRUE) * 1.15
p_main <- ggplot(plot_pair, aes(DAE, y, color = curve)) +
geom_point(alpha = 0.8, size = 2) +
geom_line(linewidth = 1) +
scale_color_grey() +
annotate("label",
x = min(plot_pair$DAE) + 2,
y = y_top - 0.02,
label = ann,
hjust = 0,
size = 4,
fill = "white") +
labs(
x = "Days after emergence (DAE)",
y = "Disease severity (proportion)",
color = "Curve"
) +
coord_cartesian(ylim = c(0, y_top))
p_main
