family   = mgcv::betar(link = "logit"),
data     = dat,
method   = "fREML",
discrete = TRUE,
gamma    = 1.4,
select   = TRUE
)
mgcv::gam.check(m_gam)
AIC(m_gam)
summary(m_gam)
mgcv::gam.check(m_gam)
summary(m_gam)
## --------------------------------------------------
## 4) Data for plotting
## --------------------------------------------------
plot_pair <- dat %>%
filter(as.character(curve_id) %in% c(id1, id2)) %>%
mutate(curve = if_else(as.character(curve_id) == id1, "A", "B"))
s1 <- dfS %>% filter(curve_id == id1)
s2 <- dfS %>% filter(curve_id == id2)
ann <- glue(
"AUDPC  A={round(s1$AUDPC,2)}  B={round(s2$AUDPC,2)}\n",
"Final Severity   A={round(s1$final_sev,2)}  B={round(s2$final_sev,2)}\n",
"d_S={signif(best$scalar_dist,3)}   d_F={signif(best$func_dist,3)}"
)
## --------------------------------------------------
## 5) Plot (RAW curves, no smoothing)
## --------------------------------------------------
y_top <- max(plot_pair$y, na.rm = TRUE) * 1.15
p_main <- ggplot(plot_pair, aes(DAE, y, color = curve)) +
geom_point(alpha = 0.8, size = 2) +
geom_line(linewidth = 1) +
scale_color_grey() +
annotate("label",
x = min(plot_pair$DAE) + 2,
y = y_top - 0.02,
label = ann,
hjust = 0,
size = 4,
fill = "white") +
labs(
x = "Days after emergence (DAE)",
y = "Disease severity (proportion)",
color = "Curve"
) +
coord_cartesian(ylim = c(0, y_top)) +
theme_classic(base_size = 12)
p_main
## --------------------------------------------------
## 1) Scalar summaries (AUDPC + final severity)
## --------------------------------------------------
dfS <- curve_stats %>%
transmute(
curve_id  = as.character(curve_id),
AUDPC     = as.numeric(AUDPC),
final_sev = as.numeric(final_sev)
) %>%
filter(is.finite(AUDPC), is.finite(final_sev)) %>%
distinct(curve_id, .keep_all = TRUE) %>%
mutate(
AUDPC_z = as.numeric(scale(AUDPC)),
final_z = as.numeric(scale(final_sev))
)
## --------------------------------------------------
## 2) All curve pairs + scalar distance
## --------------------------------------------------
pairs_scalar <- crossing(
dfS %>% rename_with(~ paste0(.x, ".x"), -curve_id) %>% rename(curve_id.x = curve_id),
dfS %>% rename_with(~ paste0(.x, ".y"), -curve_id) %>% rename(curve_id.y = curve_id)
) %>%
filter(curve_id.x < curve_id.y) %>%
mutate(
scalar_dist = sqrt((AUDPC_z.x - AUDPC_z.y)^2 +
(final_z.x - final_z.y)^2)
) %>%
arrange(scalar_dist)
## Candidate pool: closest 3% in scalar space
thr  <- quantile(pairs_scalar$scalar_dist, 0.03, na.rm = TRUE)
cand <- pairs_scalar %>% filter(scalar_dist <= thr)
## --------------------------------------------------
## 3) Functional distance (L2) on common grid
## --------------------------------------------------
interp_curve <- function(id){
df <- dat %>% filter(as.character(curve_id) == id) %>% arrange(DAE)
approx(df$DAE, df$y, xout = t_grid, rule = 2)$y
}
dt <- mean(diff(t_grid))
cand2 <- cand %>%
rowwise() %>%
mutate(
func_dist = {
y1 <- interp_curve(curve_id.x)
y2 <- interp_curve(curve_id.y)
sqrt(sum((y1 - y2)^2) * dt)
}
) %>%
ungroup()
## Select pair: max functional distance among scalar-nearest
best <- cand2 %>%
arrange(desc(func_dist), scalar_dist) %>%
slice(1)
id1 <- best$curve_id.x
id2 <- best$curve_id.y
## --------------------------------------------------
## 4) Data for plotting
## --------------------------------------------------
plot_pair <- dat %>%
filter(as.character(curve_id) %in% c(id1, id2)) %>%
mutate(curve = if_else(as.character(curve_id) == id1, "A", "B"))
s1 <- dfS %>% filter(curve_id == id1)
s2 <- dfS %>% filter(curve_id == id2)
ann <- glue(
"AUDPC  A={round(s1$AUDPC,2)}  B={round(s2$AUDPC,2)}\n",
"Final Severity   A={round(s1$final_sev,2)}  B={round(s2$final_sev,2)}\n",
"d_S={signif(best$scalar_dist,3)}   d_F={signif(best$func_dist,3)}"
)
## --------------------------------------------------
## 5) Plot (RAW curves, no smoothing)
## --------------------------------------------------
y_top <- max(plot_pair$y, na.rm = TRUE) * 1.15
p_main <- ggplot(plot_pair, aes(DAE, y, color = curve)) +
geom_point(alpha = 0.8, size = 2) +
geom_line(linewidth = 1) +
scale_color_grey() +
annotate("label",
x = min(plot_pair$DAE) + 2,
y = y_top - 0.02,
label = ann,
hjust = 0,
size = 4,
fill = "white") +
labs(
x = "Days after emergence (DAE)",
y = "Disease severity (proportion)",
color = "Curve"
) +
coord_cartesian(ylim = c(0, y_top)) +
theme_classic(base_size = 12)
p_main
#| label: killer-select-pair
dfS <- curve_stats %>%
transmute(
curve_id  = as.character(curve_id),
AUDPC     = as.numeric(AUDPC),
final_sev = as.numeric(final_sev)
) %>%
filter(is.finite(AUDPC), is.finite(final_sev)) %>%
distinct(curve_id, .keep_all = TRUE) %>%
mutate(
AUDPC_z = as.numeric(scale(AUDPC)),
final_z = as.numeric(scale(final_sev))
)
pairs_scalar <- crossing(
dfS %>% rename_with(~ paste0(.x, ".x"), -curve_id) %>% rename(curve_id.x = curve_id),
dfS %>% rename_with(~ paste0(.x, ".y"), -curve_id) %>% rename(curve_id.y = curve_id)
) %>%
filter(curve_id.x < curve_id.y) %>%
mutate(
scalar_dist = sqrt((AUDPC_z.x - AUDPC_z.y)^2 +
(final_z.x - final_z.y)^2)
) %>%
arrange(scalar_dist)
thr  <- quantile(pairs_scalar$scalar_dist, 0.03, na.rm = TRUE)
cand <- pairs_scalar %>% filter(scalar_dist <= thr)
interp_curve <- function(id){
df <- dat %>% filter(as.character(curve_id) == id) %>% arrange(DAE)
approx(df$DAE, df$y, xout = t_grid, rule = 2)$y
}
dt <- mean(diff(t_grid))
cand2 <- cand %>%
rowwise() %>%
mutate(
func_dist = {
y1 <- interp_curve(curve_id.x)
y2 <- interp_curve(curve_id.y)
sqrt(sum((y1 - y2)^2) * dt)
}
) %>%
ungroup()
best <- cand2 %>%
arrange(desc(func_dist), scalar_dist) %>%
slice(1)
id1 <- best$curve_id.x
id2 <- best$curve_id.y
best
#| label: killer-plot-raw
plot_pair <- dat %>%
filter(as.character(curve_id) %in% c(id1, id2)) %>%
mutate(curve = if_else(as.character(curve_id) == id1, "A", "B"))
s1 <- dfS %>% filter(curve_id == id1)
s2 <- dfS %>% filter(curve_id == id2)
ann <- glue(
"AUDPC  A={round(s1$AUDPC,2)}  B={round(s2$AUDPC,2)}\n",
"Final   A={round(s1$final_sev,2)}  B={round(s2$final_sev,2)}\n",
"d_S={signif(best$scalar_dist,3)}   d_F={signif(best$func_dist,3)}"
)
y_top <- max(plot_pair$y, na.rm = TRUE) * 1.15
p_main <- ggplot(plot_pair, aes(DAE, y, color = curve)) +
geom_point(alpha = 0.8, size = 2) +
geom_line(linewidth = 1) +
scale_color_grey() +
annotate("label",
x = min(plot_pair$DAE) + 2,
y = y_top - 0.02,
label = ann,
hjust = 0,
size = 4,
fill = "white") +
labs(
x = "Days after emergence (DAE)",
y = "Disease severity (proportion)",
color = "Curve"
) +
coord_cartesian(ylim = c(0, y_top))
p_main
## ---------------------------
## 0) Packages
## ---------------------------
pkgs <- c(
"readr","dplyr","tidyr","tibble","purrr",
"ggplot2","mgcv","pracma","pheatmap",
"lme4","lmerTest","emmeans","multcompView",
"cowplot"
)
to_install <- pkgs[!pkgs %in% rownames(installed.packages())]
if(length(to_install) > 0) install.packages(to_install, dependencies = TRUE)
library(readr)
library(dplyr)
library(tidyr)
library(tibble)
library(purrr)
library(ggplot2)
library(mgcv)
library(pracma)
library(pheatmap)
library(lme4)
library(lmerTest)
library(emmeans)
library(multcompView)
library(cowplot)
theme_set(theme_classic(base_size = 14))
## ---------------------------
## 1) Read + prepare data
## ---------------------------
file_path <- "Milho_Doencas_2024.xlsx.csv"
dat0 <- read_csv(file_path, show_col_types = FALSE)
dat0 <- dat0 |>
filter(DAE < 116) |>
filter(DAE > 20)
## Expected columns: Ambiente, Hibrido, Parcela, DAE, Bipolaris
dat <- dat0 %>%
transmute(
Ambiente  = factor(Ambiente),
Hibrido   = factor(Hibrido),
Parcela   = factor(Parcela),
DAE       = as.numeric(DAE),
bipolaris = as.numeric(Bipolaris) / 100  # convert % -> proportion
) %>%
filter(!is.na(Ambiente), !is.na(Hibrido), !is.na(Parcela),
!is.na(DAE), !is.na(bipolaris)) %>%
mutate(
## curve_id = unique epidemic per environment × hybrid × block
curve_id = interaction(Ambiente, Hibrido, Parcela, drop = TRUE, sep = "|")
) %>%
arrange(curve_id, DAE)
## Keep curves with >= 8 assessments (as you specified)
curve_n <- dat %>% count(curve_id, name = "n_assess")
dat <- dat %>%
left_join(curve_n, by = "curve_id") %>%
filter(n_assess >= 5) %>%
dplyr::select(-n_assess)
## Beta regression requires 0<y<1 (avoid 0/1 exactly)
eps <- 1e-4
dat <- dat %>%
mutate(y = pmin(pmax(bipolaris, eps), 1 - eps))
message("Rows: ", nrow(dat),
" | curves: ", n_distinct(dat$curve_id),
" | hybrids: ", n_distinct(dat$Hibrido),
" | envs: ", n_distinct(dat$Ambiente))
dat
bipolaris_df <- data.frame(
Hibrido = c(
"AG 8701 PRO4",
"AG 8707 PRO4",
"AG 9021 PRO3",
"AS 1757 PRO4",
"AS 1868 PRO4",
"AS 1955 PRO4",
"B 2801 PWU",
"CRWX03",
"DKB 230 PRO3",
"DKB 242 PRO4",
"MG 616 PWU",
"P 3016 VYHR",
"T 1503 PWU"
),
resistance = c(
"MR",
"MR",
"MR",
"MR",
"R",
"MR",
"MR",
"R",
"MR",
"MR",
"MR",
"R",
"MR"
),
stringsAsFactors = FALSE
)
dat <- left_join(dat, bipolaris_df)
dat <- dat %>%
transmute(
y        = as.numeric(y),
DAE      = as.numeric(DAE),
Ambiente = factor(Ambiente),
Hibrido  = factor(Hibrido),     # <-- critical fix (was chr)
curve_id = factor(curve_id),
resistance = factor(resistance)# keep as factor for re smooth
) %>%
as.data.frame()
str(dat)
## T50 = time when y reaches 0.5*ymax (linear interpolation)
t50_interp <- function(time, y){
o <- order(time)
time <- time[o]; y <- y[o]
ymax <- max(y, na.rm = TRUE)
thr  <- 0.5 * ymax
if(all(y < thr, na.rm = TRUE)) return(NA_real_)
k <- which(y >= thr)[1]
if(k == 1) return(time[1])
t1 <- time[k-1]; t2 <- time[k]
y1 <- y[k-1];    y2 <- y[k]
if(isTRUE(all.equal(y2, y1))) return(t2)
t1 + (thr - y1) * (t2 - t1) / (y2 - y1)
}
## Logistic fit: y(t)=K/(1+exp(-r(t-t0))) and r_norm = r*(tmax-tmin)
logistic_fit_rate <- function(time, y){
o <- order(time)
time <- time[o]; y <- y[o]
y <- pmin(pmax(y, 1e-4), 1 - 1e-4)
K0 <- max(y)
d  <- diff(y)
t00 <- if(length(d) > 0 && any(is.finite(d))) time[which.max(d) + 1] else median(time)
if(is.na(t00)) t00 <- median(time)
r0 <- 0.1
f <- tryCatch(
nls(
y ~ K / (1 + exp(-r * (time - t0))),
start = list(K = K0, r = r0, t0 = t00),
control = nls.control(maxiter = 200, warnOnly = TRUE)
),
error = function(e) NULL
)
if(is.null(f)) return(tibble(r = NA_real_, K = NA_real_, t0 = NA_real_, r_norm = NA_real_))
co <- coef(f)
r  <- unname(co["r"])
K  <- unname(co["K"])
t0 <- unname(co["t0"])
dur <- max(time) - min(time)
tibble(r = r, K = K, t0 = t0, r_norm = r * dur)
}
## ---------------------------
## 3) Per-curve scalar metrics (AUDPC, final, T50, r_norm)
## ---------------------------
curve_stats <- dat %>%
group_by(curve_id, Ambiente, Hibrido) %>%
summarise(
AUDPC     = trapz(DAE, y),
final_sev = y[which.max(DAE)],
T50       = t50_interp(DAE, y),
.groups   = "drop"
)
rate_df <- map_dfr(unique(curve_stats$curve_id), function(cid){
df <- dat %>% filter(curve_id == cid)
logistic_fit_rate(df$DAE, df$y) %>% mutate(curve_id = as.character(cid))
})
curve_stats <- curve_stats %>%
mutate(curve_id = as.character(curve_id)) %>%
left_join(rate_df, by = "curve_id") %>%
filter(is.finite(T50), is.finite(r_norm))
message("Curves with all 4 metrics: ", nrow(curve_stats))
## ---------------------------
## 4) Hierarchical beta-GAM (HGAM)
## ---------------------------
## - s(DAE): global mean epidemic shape
## - s(DAE,Ambiente,bs="fs"): env-specific deviations (random smooth)
## - s(DAE,Hibrido,bs="fs"): cultivar-specific deviations (random smooth)
## - s(curve_id,bs="re"): curve-level random intercept
set.seed(1)
## --------------------------------------------------
## 1) Scalar summaries (AUDPC + final severity)
## --------------------------------------------------
dfS <- curve_stats %>%
transmute(
curve_id  = as.character(curve_id),
AUDPC     = as.numeric(AUDPC),
final_sev = as.numeric(final_sev)
) %>%
filter(is.finite(AUDPC), is.finite(final_sev)) %>%
distinct(curve_id, .keep_all = TRUE) %>%
mutate(
AUDPC_z = as.numeric(scale(AUDPC)),
final_z = as.numeric(scale(final_sev))
)
## --------------------------------------------------
## 2) All curve pairs + scalar distance
## --------------------------------------------------
pairs_scalar <- crossing(
dfS %>% rename_with(~ paste0(.x, ".x"), -curve_id) %>% rename(curve_id.x = curve_id),
dfS %>% rename_with(~ paste0(.x, ".y"), -curve_id) %>% rename(curve_id.y = curve_id)
) %>%
filter(curve_id.x < curve_id.y) %>%
mutate(
scalar_dist = sqrt((AUDPC_z.x - AUDPC_z.y)^2 +
(final_z.x - final_z.y)^2)
) %>%
arrange(scalar_dist)
## Candidate pool: closest 3% in scalar space
thr  <- quantile(pairs_scalar$scalar_dist, 0.03, na.rm = TRUE)
cand <- pairs_scalar %>% filter(scalar_dist <= thr)
## --------------------------------------------------
## 3) Functional distance (L2) on common grid
## --------------------------------------------------
interp_curve <- function(id){
df <- dat %>% filter(as.character(curve_id) == id) %>% arrange(DAE)
approx(df$DAE, df$y, xout = t_grid, rule = 2)$y
}
dt <- mean(diff(t_grid))
cand2 <- cand %>%
rowwise() %>%
mutate(
func_dist = {
y1 <- interp_curve(curve_id.x)
y2 <- interp_curve(curve_id.y)
sqrt(sum((y1 - y2)^2) * dt)
}
) %>%
ungroup()
## Select pair: max functional distance among scalar-nearest
best <- cand2 %>%
arrange(desc(func_dist), scalar_dist) %>%
slice(1)
id1 <- best$curve_id.x
id2 <- best$curve_id.y
## --------------------------------------------------
## 4) Data for plotting
## --------------------------------------------------
plot_pair <- dat %>%
filter(as.character(curve_id) %in% c(id1, id2)) %>%
mutate(curve = if_else(as.character(curve_id) == id1, "A", "B"))
s1 <- dfS %>% filter(curve_id == id1)
s2 <- dfS %>% filter(curve_id == id2)
ann <- glue(
"AUDPC  A={round(s1$AUDPC,2)}  B={round(s2$AUDPC,2)}\n",
"Final Severity   A={round(s1$final_sev,2)}  B={round(s2$final_sev,2)}\n",
"d_S={signif(best$scalar_dist,3)}   d_F={signif(best$func_dist,3)}"
)
## --------------------------------------------------
## 5) Plot (RAW curves, no smoothing)
## --------------------------------------------------
y_top <- max(plot_pair$y, na.rm = TRUE) * 1.15
p_main <- ggplot(plot_pair, aes(DAE, y, color = curve)) +
geom_point(alpha = 0.8, size = 2) +
geom_line(linewidth = 1) +
scale_color_grey() +
annotate("label",
x = min(plot_pair$DAE) + 2,
y = y_top - 0.02,
label = ann,
hjust = 0,
size = 4,
fill = "white") +
labs(
x = "Days after emergence (DAE)",
y = "Disease severity (proportion)",
color = "Curve"
) +
coord_cartesian(ylim = c(0, y_top)) +
theme_classic(base_size = 12)
p_main
ann <- glue(
"AUDPC  A={round(s1$AUDPC,2)}  B={round(s2$AUDPC,2)}\n",
"Final Severity   A={round(s1$final_sev,2)}  B={round(s2$final_sev,2)}\n"
)
## --------------------------------------------------
## 5) Plot (RAW curves, no smoothing)
## --------------------------------------------------
y_top <- max(plot_pair$y, na.rm = TRUE) * 1.15
p_main <- ggplot(plot_pair, aes(DAE, y, color = curve)) +
geom_point(alpha = 0.8, size = 2) +
geom_line(linewidth = 1) +
scale_color_grey() +
annotate("label",
x = min(plot_pair$DAE) + 2,
y = y_top - 0.02,
label = ann,
hjust = 0,
size = 4,
fill = "white") +
labs(
x = "Days after emergence (DAE)",
y = "Disease severity (proportion)",
color = "Curve"
) +
coord_cartesian(ylim = c(0, y_top)) +
theme_classic(base_size = 12)
p_main
setwd("~/Documents/GitHub/paper-hgam-curves")
